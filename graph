import React, { useRef, useEffect, useState } from 'react';

interface GraphProps {
  xData: number[];
  yData: number[];
  width?: number;
  height?: number;
  margin?: number;
  lineColor?: string;
  pointColor?: string;
  gridColor?: string;
}

const Graph: React.FC<GraphProps> = ({
  xData,
  yData,
  width = 600,
  height = 400,
  margin = 50,
  lineColor = '#007acc',
  pointColor = '#ff4444',
  gridColor = '#e0e0e0'
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hoveredPoint, setHoveredPoint] = useState<number | null>(null);

  // Проверка данных
  if (xData.length !== yData.length || xData.length === 0) {
    return <div>Ошибка: массивы данных должны быть одинаковой длины и не пустыми</div>;
  }

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Очистка canvas
    ctx.clearRect(0, 0, width, height);

    // Вычисляем границы данных
    const minX = Math.min(...xData);
    const maxX = Math.max(...xData);
    const minY = Math.min(...yData);
    const maxY = Math.max(...yData);

    // Масштабирующие коэффициенты
    const scaleX = (width - 2 * margin) / (maxX - minX || 1);
    const scaleY = (height - 2 * margin) / (maxY - minY || 1);

    // Функция для преобразования координат данных в координаты canvas
    const toCanvasX = (x: number) => margin + (x - minX) * scaleX;
    const toCanvasY = (y: number) => height - margin - (y - minY) * scaleY;

    // Рисуем сетку
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 1;
    
    // Вертикальные линии сетки
    for (let x = minX; x <= maxX; x += (maxX - minX) / 5) {
      const canvasX = toCanvasX(x);
      ctx.beginPath();
      ctx.moveTo(canvasX, margin);
      ctx.lineTo(canvasX, height - margin);
      ctx.stroke();
      
      // Подписи по оси X
      ctx.fillStyle = '#666';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(x.toFixed(2), canvasX, height - margin + 20);
    }

    // Горизонтальные линии сетки
    for (let y = minY; y <= maxY; y += (maxY - minY) / 5) {
      const canvasY = toCanvasY(y);
      ctx.beginPath();
      ctx.moveTo(margin, canvasY);
      ctx.lineTo(width - margin, canvasY);
      ctx.stroke();
      
      // Подписи по оси Y
      ctx.fillStyle = '#666';
      ctx.font = '12px Arial';
      ctx.textAlign = 'right';
      ctx.fillText(y.toFixed(2), margin - 10, canvasY + 4);
    }

    // Оси
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    
    // Ось X
    ctx.beginPath();
    ctx.moveTo(margin, height - margin);
    ctx.lineTo(width - margin, height - margin);
    ctx.stroke();

    // Ось Y
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, height - margin);
    ctx.stroke();

    // Рисуем линию графика
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 2;
    ctx.beginPath();

    xData.forEach((x, index) => {
      const canvasX = toCanvasX(x);
      const canvasY = toCanvasY(yData[index]);
      
      if (index === 0) {
        ctx.moveTo(canvasX, canvasY);
      } else {
        ctx.lineTo(canvasX, canvasY);
      }
    });
    ctx.stroke();

    // Рисуем точки
    ctx.fillStyle = pointColor;
    xData.forEach((x, index) => {
      const canvasX = toCanvasX(x);
      const canvasY = toCanvasY(yData[index]);
      
      ctx.beginPath();
      ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
      ctx.fill();
    });

    // Подсвечиваем точку при наведении
    if (hoveredPoint !== null) {
      const canvasX = toCanvasX(xData[hoveredPoint]);
      const canvasY = toCanvasY(yData[hoveredPoint]);
      
      // Большая точка
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(canvasX, canvasY, 6, 0, 2 * Math.PI);
      ctx.fill();
      
      // Текст с координатами
      ctx.fillStyle = '#000';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(
        `(${xData[hoveredPoint].toFixed(2)}, ${yData[hoveredPoint].toFixed(2)})`,
        canvasX + 10,
        canvasY - 10
      );
    }

  }, [xData, yData, width, height, margin, lineColor, pointColor, gridColor, hoveredPoint]);

  // Обработчик для определения точки под курсором
  const handleMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    // Вычисляем границы данных
    const minX = Math.min(...xData);
    const maxX = Math.max(...xData);
    const minY = Math.min(...yData);
    const maxY = Math.max(...yData);

    // Масштабирующие коэффициенты
    const scaleX = (width - 2 * margin) / (maxX - minX || 1);
    const scaleY = (height - 2 * margin) / (maxY - minY || 1);

    const toDataX = (canvasX: number) => minX + (canvasX - margin) / scaleX;
    const toDataY = (canvasY: number) => minY + (height - margin - canvasY) / scaleY;

    const dataX = toDataX(mouseX);
    const dataY = toDataY(mouseY);

    // Находим ближайшую точку
    let closestIndex = -1;
    let minDistance = Infinity;

    xData.forEach((x, index) => {
      const canvasX = margin + (x - minX) * scaleX;
      const canvasY = height - margin - (yData[index] - minY) * scaleY;
      
      const distance = Math.sqrt(
        Math.pow(mouseX - canvasX, 2) + Math.pow(mouseY - canvasY, 2)
      );

      if (distance < 20 && distance < minDistance) {
        minDistance = distance;
        closestIndex = index;
      }
    });

    setHoveredPoint(closestIndex !== -1 ? closestIndex : null);
  };

  const handleMouseLeave = () => {
    setHoveredPoint(null);
  };

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', display: 'inline-block' }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        onMouseMove={handleMouseMove}
        onMouseLeave={handleMouseLeave}
        style={{ cursor: 'pointer' }}
      />
    </div>
  );
};

// Пример использования компонента
const App: React.FC = () => {
  // Пример данных
  const xData = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  const yData = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]; // y = x²

  // Синусоидальные данные
  const sinX = Array.from({ length: 100 }, (_, i) => i * 0.1);
  const sinY = sinX.map(x => Math.sin(x) * 10);

  return (
    <div style={{ padding: '20px' }}>
      <h2>График функции y = x²</h2>
      <Graph
        xData={xData}
        yData={yData}
        width={800}
        height={500}
        lineColor="#007acc"
        pointColor="#ff4444"
      />

      <h2 style={{ marginTop: '40px' }}>График синусоиды</h2>
      <Graph
        xData={sinX}
        yData={sinY}
        width={800}
        height={500}
        lineColor="#00cc66"
        pointColor="#8844ff"
      />
    </div>
  );
};

export default App;
