import React, { useRef, useEffect, useState, useCallback } from 'react';

interface GammaLogProps {
  depthData: number[];
  gammaData: number[];
  width?: number;
  height?: number;
  margin?: {
    top: number;
    right: number;
    bottom: number;
    left: number;
  };
  lineColor?: string;
  fillColor?: string;
  gridColor?: string;
  trackWidth?: number;
}

const GammaLog: React.FC<GammaLogProps> = ({
  depthData,
  gammaData,
  width = 400,
  height = 800,
  margin = { top: 20, right: 60, bottom: 40, left: 80 },
  lineColor = '#0066cc',
  fillColor = '#0066cc33',
  gridColor = '#cccccc',
  trackWidth = 200
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hoveredPoint, setHoveredPoint] = useState<number | null>(null);

  // Вычисляем границы данных
  const calculateScales = useCallback(() => {
    const minDepth = Math.min(...depthData);
    const maxDepth = Math.max(...depthData);
    const minGamma = 0; // Гамма обычно от 0
    const maxGamma = Math.max(...gammaData) * 1.1; // +10% для отступа

    const depthRange = maxDepth - minDepth;
    const gammaRange = maxGamma - minGamma;

    const scaleDepth = (height - margin.top - margin.bottom) / (depthRange || 1);
    const scaleGamma = trackWidth / (gammaRange || 1);

    return {
      minDepth,
      maxDepth,
      minGamma,
      maxGamma,
      scaleDepth,
      scaleGamma
    };
  }, [depthData, gammaData, height, margin, trackWidth]);

  // Функции преобразования координат
  const getCoordinateConverters = useCallback((scales: ReturnType<typeof calculateScales>) => {
    const { minDepth, minGamma, scaleDepth, scaleGamma } = scales;
    
    return {
      toCanvasDepth: (depth: number) => margin.top + (depth - minDepth) * scaleDepth,
      toCanvasGamma: (gamma: number) => margin.left + (gamma - minGamma) * scaleGamma
    };
  }, [margin]);

  // Отрисовка графика
  const drawGraph = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Очистка canvas
    ctx.clearRect(0, 0, width, height);

    const scales = calculateScales();
    const { toCanvasDepth, toCanvasGamma } = getCoordinateConverters(scales);

    // Фон трека
    ctx.fillStyle = '#f9f9f9';
    ctx.fillRect(margin.left, margin.top, trackWidth, height - margin.top - margin.bottom);
    
    // Рамка трека
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.strokeRect(margin.left, margin.top, trackWidth, height - margin.top - margin.bottom);

    // Сетка по глубине
    ctx.strokeStyle = gridColor;
    ctx.lineWidth = 0.5;
    ctx.font = '12px Arial';
    ctx.fillStyle = '#666';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';

    const depthStep = 10; // Шаг сетки по глубине 10 метров
    for (let depth = Math.ceil(scales.minDepth / depthStep) * depthStep; 
         depth <= scales.maxDepth; 
         depth += depthStep) {
      
      const canvasY = toCanvasDepth(depth);
      
      // Линия сетки
      ctx.beginPath();
      ctx.moveTo(margin.left, canvasY);
      ctx.lineTo(margin.left + trackWidth, canvasY);
      ctx.stroke();

      // Подпись глубины
      ctx.fillText(`${depth}`, margin.left - 10, canvasY);
    }

    // Сетка по гамме
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    
    const gammaStep = 50; // Шаг сетки по гамме
    for (let gamma = 0; gamma <= scales.maxGamma; gamma += gammaStep) {
      const canvasX = toCanvasGamma(gamma);
      
      // Линия сетки
      ctx.beginPath();
      ctx.moveTo(canvasX, margin.top);
      ctx.lineTo(canvasX, height - margin.bottom);
      ctx.stroke();

      // Подпись гаммы
      ctx.fillText(`${gamma}`, canvasX, height - margin.bottom + 5);
    }

    // Заголовок оси гаммы
    ctx.save();
    ctx.translate(margin.left - 40, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.font = '14px Arial';
    ctx.fillStyle = '#000';
    ctx.fillText('Общая гамма, API', 0, 0);
    ctx.restore();

    // Заголовок оси глубины
    ctx.textAlign = 'center';
    ctx.font = '14px Arial';
    ctx.fillText('Глубина, м', width / 2, height - 10);

    // Рисуем заполненную область и линию
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 2;

    ctx.beginPath();
    
    // Начинаем с левого края
    ctx.moveTo(margin.left, toCanvasDepth(depthData[0]));
    
    // Рисуем линию графика
    for (let i = 0; i < depthData.length; i++) {
      const canvasY = toCanvasDepth(depthData[i]);
      const canvasX = toCanvasGamma(gammaData[i]);
      
      ctx.lineTo(canvasX, canvasY);
    }
    
    // Замыкаем область до правого края
    ctx.lineTo(margin.left + trackWidth, toCanvasDepth(depthData[depthData.length - 1]));
    
    // И обратно к началу по левому краю
    for (let i = depthData.length - 1; i >= 0; i--) {
      ctx.lineTo(margin.left, toCanvasDepth(depthData[i]));
    }
    
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Тонкая линия поверх
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    for (let i = 0; i < depthData.length; i++) {
      const canvasY = toCanvasDepth(depthData[i]);
      const canvasX = toCanvasGamma(gammaData[i]);
      
      if (i === 0) {
        ctx.moveTo(canvasX, canvasY);
      } else {
        ctx.lineTo(canvasX, canvasY);
      }
    }
    
    ctx.stroke();

    // Подсветка точки при наведении
    if (hoveredPoint !== null && hoveredPoint >= 0 && hoveredPoint < depthData.length) {
      const canvasY = toCanvasDepth(depthData[hoveredPoint]);
      const canvasX = toCanvasGamma(gammaData[hoveredPoint]);
      
      // Точка
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
      ctx.fill();
      
      // Информация
      ctx.fillStyle = '#000';
      ctx.font = '12px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(
        `Глубина: ${depthData[hoveredPoint]}м, Гамма: ${gammaData[hoveredPoint].toFixed(1)} API`,
        canvasX + 10,
        canvasY - 10
      );
    }
  }, [depthData, gammaData, width, height, margin, lineColor, fillColor, gridColor, trackWidth, hoveredPoint, calculateScales, getCoordinateConverters]);

  // Обработчик мыши
  const handleMouseMove = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    const scales = calculateScales();
    const { toCanvasDepth } = getCoordinateConverters(scales);

    // Находим ближайшую точку по глубине
    let closestIndex = -1;
    let minDistance = Infinity;

    for (let i = 0; i < depthData.length; i++) {
      const canvasY = toCanvasDepth(depthData[i]);
      const distance = Math.abs(mouseY - canvasY);

      if (distance < 5 && distance < minDistance) {
        minDistance = distance;
        closestIndex = i;
      }
    }

    setHoveredPoint(closestIndex);
  }, [depthData, calculateScales, getCoordinateConverters]);

  const handleMouseLeave = useCallback(() => {
    setHoveredPoint(null);
  }, []);

  useEffect(() => {
    drawGraph();
  }, [drawGraph]);

  // Проверка данных после хуков
  if (depthData.length !== gammaData.length || depthData.length === 0) {
    return <div>Ошибка: массивы глубины и гаммы должны быть одинаковой длины и не пустыми</div>;
  }

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', display: 'inline-block' }}>
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        onMouseMove={handleMouseMove}
        onMouseLeave={handleMouseLeave}
        style={{ cursor: 'crosshair' }}
      />
    </div>
  );
};

// Пример использования с данными каротажа
const App: React.FC = () => {
  // Генерация тестовых данных каротажа
  const generateLogData = () => {
    const depthData: number[] = [];
    const gammaData: number[] = [];
    
    for (let depth = 20; depth <= 200; depth += 2) {
      depthData.push(depth);
      
      // Имитация данных гамма-каротажа с некоторыми аномалиями
      let gamma = 50 + Math.random() * 30;
      
      // Добавляем некоторые аномалии
      if (depth > 80 && depth < 100) {
        gamma += 40 + Math.random() * 30; // Пласт с высокой гаммой
      } else if (depth > 140 && depth < 160) {
        gamma += 20 + Math.random() * 20; // Другой пласт
      }
      
      gammaData.push(gamma);
    }
    
    return { depthData, gammaData };
  };

  const { depthData, gammaData } = generateLogData();

  return (
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <h2>Гамма-каротаж</h2>
      <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>
        <GammaLog
          depthData={depthData}
          gammaData={gammaData}
          width={350}
          height={600}
          trackWidth={150}
        />
        
        {/* Легенда и информация */}
        <div style={{ minWidth: '200px' }}>
          <h3>Параметры:</h3>
          <div style={{ fontSize: '14px', lineHeight: '1.5' }}>
            <div>Глубина: 20-200 м</div>
            <div>Гамма-излучение: 0-150 API</div>
            <div>Точки данных: {depthData.length}</div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default App;
